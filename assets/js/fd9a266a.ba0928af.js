"use strict";(self.webpackChunkthreader=self.webpackChunkthreader||[]).push([[782],{277:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=r(5893),a=r(1151);const o={sidebar_position:3},i=void 0,s={id:"Examples/Terrain generation",title:"Terrain generation",description:"This example will showcase how terrain generation with trees can be made using multi-threading.",source:"@site/docs/Examples/Terrain generation.mdx",sourceDirName:"Examples",slug:"/Examples/Terrain generation",permalink:"/Threader/docs/Examples/Terrain generation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ThreadWorker",permalink:"/Threader/docs/ThreadWorker"}},l={},c=[{value:"Runner script",id:"runner-script",level:2},{value:"TerrainGeneratorWorker",id:"terraingeneratorworker",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["This example will showcase how terrain generation with trees can be made using multi-threading.\nThe base script was based on ",(0,t.jsx)(n.a,{href:"https://www.youtube.com/watch?v=yA210k9ie8Y&t=2s",children:"this video"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"runner-script",children:"Runner script"}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:"Source"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'type TerrainData = {\n    x: number,\n    z: number,\n    seed: number,\n    resolution: number,\n    frequency: number,\n    magnitude: number,\n    waterHeight: number,\n    extraHeigt: number,\n}\n\nlocal TerrainDataType = require(script.TerrainDataType)\nlocal Threader = require(game:GetService("ReplicatedStorage").Threader)\n\nlocal TerrainGenerationThreader = Threader.new(10, script.TerrainGeneratorWorker)\n\n-- define values that will be used to generate the terrain\n-- NOTE: terrainSize determines how big of an area will the terrain occupy\nlocal terrainSize = 200 -- terrainSize^2\nlocal seed = 2\nlocal resolution = 100\nlocal frequency = 5\nlocal magnitude = 15\nlocal waterHeight = Random.new(seed):NextNumber()\nlocal extraHeigt = 15\n\n-- generate `workData`\nlocal terrainPositions = {} :: { TerrainData }\n\nfor x = 1, terrainSize do\n    for z = 1, terrainSize do\n        table.insert(terrainPositions, {\n            x = x,\n            z = z,\n            seed = seed,\n            resolution = resolution,\n            frequency = frequency,\n            magnitude = magnitude,\n            waterHeight = waterHeight,\n            extraHeigt = extraHeigt,\n        })\n    end\nend\n\ntask.wait(3) -- added to have a bit of an intermission until the whole pc freezes :)\n\nTerrainGenerationThreader:Dispatch(terrainPositions):andThen(function()\n    local waterBlock = Instance.new("Part")\n    waterBlock.Name = "Water"\n    waterBlock.Size = Vector3.new(terrainSize, 1, terrainSize)\n    waterBlock.Position =\n        Vector3.new(terrainSize / 2 + 0.5, extraHeigt + waterHeight * magnitude, terrainSize / 2 + 0.5)\n    waterBlock.Color = Color3.fromRGB(41, 109, 255)\n    waterBlock.Transparency = 0.6\n    waterBlock.Anchored = true\n    waterBlock.Parent = workspace\nend)\n'})})]}),"\n",(0,t.jsx)(n.p,{children:"The runner script is responsible to dispatch all the work to the threads and prepare the most crucial data\nfor each thread."}),"\n",(0,t.jsxs)(n.p,{children:["Before calling ",(0,t.jsx)(n.code,{children:"Threader:Dispatch()"})," on our ",(0,t.jsx)(n.em,{children:"TerrainGenerationThreader"})," class, we have to first make a ",(0,t.jsx)(n.code,{children:"workData"}),"\ntable that contains every voxel's data: ",(0,t.jsx)(n.strong,{children:"x"}),", ",(0,t.jsx)(n.strong,{children:"z"}),", ",(0,t.jsx)(n.strong,{children:"seed"}),", ",(0,t.jsx)(n.strong,{children:"resolution"}),", ",(0,t.jsx)(n.strong,{children:"frequency"}),", ",(0,t.jsx)(n.strong,{children:"magnitude"}),", ",(0,t.jsx)(n.strong,{children:"waterHeight"}),", ",(0,t.jsx)(n.strong,{children:"extraHeigt"}),".\nEach of them is used for a different purpose: ",(0,t.jsx)(n.strong,{children:"x"})," and ",(0,t.jsx)(n.strong,{children:"z"})," is used for coordinates and in generating the perlin noise using the seed. The ",(0,t.jsx)(n.strong,{children:"resolution"}),"\ndetermines how smooth will the perlin noise be. The ",(0,t.jsx)(n.strong,{children:"frequency"})," makes the perlin noise have bigger fluctuation and the ",(0,t.jsx)(n.strong,{children:"magnitude"})," increases the height."]}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.em,{children:"TerrainGenerationThreader"})," had dispatched and all the threads had reported back with no errors then ",(0,t.jsx)(n.code,{children:":andThen"})," method gets ran, in which\nwe create a part to represent water."]}),"\n",(0,t.jsx)(n.h2,{id:"terraingeneratorworker",children:"TerrainGeneratorWorker"}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:"Source"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:'type TerrainData = {\n    x: number,\n    z: number,\n    seed: number,\n    resolution: number,\n    frequency: number,\n    magnitude: number,\n    waterHeight: number,\n    extraHeigt: number,\n}\n\nlocal ServerScriptService = game:GetService("ServerScriptService")\n\nlocal TerrainDataType = require(ServerScriptService.ThreaderServer.TerrainDataType)\nlocal Threader = require(game:GetService("ReplicatedStorage").Threader)\n\nlocal TerrainGeneratorWorker = Threader.ThreadWorker.new()\n\nfunction TerrainGeneratorWorker:OnDispatch(terrainSet: { TerrainData })\n    -- create an RNG generator with the seed\n    local randomNumberGenerator = Random.new(terrainSet[1].seed)\n\n    for _, terrainData in terrainSet do\n        task.desynchronize()\n\n        -- generate perlin noise\n        local noiseY = math.noise(\n            terrainData.x / terrainData.resolution * terrainData.frequency,\n            terrainData.z / terrainData.resolution * terrainData.frequency,\n            13 / (terrainData.seed - 0.01)\n        ) + 0.5\n\n        local partSize = Vector3.one + Vector3.yAxis * 2\n        local partPosition =\n            Vector3.new(terrainData.x, noiseY * terrainData.magnitude - 1 + terrainData.extraHeigt, terrainData.z)\n        local partColor = nil\n\n        local distanceFromWaterLevel = noiseY - terrainData.waterHeight\n\n        -- above water\n        if distanceFromWaterLevel > 0.1 then\n            partColor = Color3.fromRGB(13, 134, 17)\n        -- below water\n        elseif distanceFromWaterLevel < 0 then\n            partColor = Color3.fromRGB(176, 86, 26)\n        -- at edge\n        else\n            partColor = Color3.fromRGB(208, 204, 91)\n        end\n\n        task.synchronize()\n\n        local part = Instance.new("Part")\n        part.Size = partSize\n        part.Position = partPosition\n        part.Anchored = true\n        part.Color = partColor\n        part.Parent = workspace.Terrain\n\n        -- Tree generation\n        if not (distanceFromWaterLevel > 0.15 and distanceFromWaterLevel < 0.5) then\n            continue\n        end\n\n        task.desynchronize()\n\n        local offsetX = randomNumberGenerator:NextNumber(-0.3, 0.3)\n        local offsetY = randomNumberGenerator:NextNumber(-0.4, 0.3)\n        local offsetZ = randomNumberGenerator:NextNumber(-0.3, 0.3)\n\n        local trunkSize = 1.5\n\n        local foliagePosition = Vector3.yAxis * trunkSize - Vector3.yAxis * 0.345\n        local treePosition =\n            CFrame.new(terrainData.x + offsetX, part.Position.Y + part.Size.Y - 1 + offsetY, terrainData.z + offsetZ)\n\n        task.synchronize()\n\n        local tree = Instance.new("Model")\n        tree.Name = "Tree"\n        tree.Parent = workspace.Terrain\n\n        local trunk = Instance.new("Part")\n        trunk.Color = Color3.fromRGB(176, 86, 26)\n        trunk.Size = Vector3.new(0.273, trunkSize, 0.273)\n        trunk.Anchored = true\n        trunk.Name = "Trunk"\n        trunk.Parent = tree\n\n        local foliage = Instance.new("Part")\n        foliage.Shape = Enum.PartType.Ball\n        foliage.Color = Color3.fromRGB(75, 151, 75)\n        foliage.Name = "Foliage"\n        foliage.Anchored = true\n        foliage.Position = foliagePosition\n        foliage.TopSurface = Enum.SurfaceType.Smooth\n        foliage.Parent = tree\n\n        tree.PrimaryPart = trunk\n\n        tree:SetPrimaryPartCFrame(treePosition)\n\n        for _, collideTree in foliage:GetTouchingParts() do\n            if not (collideTree.Name == "Foliage") then\n                continue\n            end\n\n            tree:Destroy()\n        end\n    end\nend\n\nreturn TerrainGeneratorWorker\n'})})]}),"\n",(0,t.jsxs)(n.p,{children:["This is the main part of our terrain generation. The worker generates a perlin noise with the given ",(0,t.jsx)(n.strong,{children:"x"}),", ",(0,t.jsx)(n.strong,{children:"z"}),", ",(0,t.jsx)(n.strong,{children:"seed"}),", ",(0,t.jsx)(n.strong,{children:"frequency"})," and\n",(0,t.jsx)(n.strong,{children:"magnitude"})," values and uses it to position the voxel approprietly. After the perlin noise a.k.a. the ",(0,t.jsx)(n.strong,{children:"y"})," value of the coordinate\nhas been calculated, the distance from the water height gets determined that results in the voxel either becoming: ",(0,t.jsx)(n.strong,{children:"grass"}),",\n",(0,t.jsx)(n.strong,{children:"sand"}),", ",(0,t.jsx)(n.strong,{children:"dirt"}),". After the voxel was generated and positioned accordingly a tree will be generated at the voxel if the distance\nfrom the water falls between the range of ",(0,t.jsx)(n.strong,{children:"0.15"})," and ",(0,t.jsx)(n.strong,{children:"0.5"}),". After the tree was moved to its position but collides with another tree it gets destroyed."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,r)=>{r.d(n,{Z:()=>s,a:()=>i});var t=r(7294);const a={},o=t.createContext(a);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);